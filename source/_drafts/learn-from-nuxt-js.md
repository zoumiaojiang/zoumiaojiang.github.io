---
title: 从 Nuxt.js 学习到了什么？
catalog: true
subtitle: 窥探前端工程化解决方案的架构思路
header-img: lego-header.jpg
tags:
- 架构
- 开源
- Nuxt.js

categories:
- 架构
---

这段时间由于工作需要，对 Nuxt.js 这个框架进行了一些深入的研究，从中学习到了一些东西，所以写下来分享一下。我本人对 Nuxt.js 高度认可，我甚至觉得这种前端工程化的解决方案的架构模式正是我们所需要去学习和借鉴的一种非常优秀的实践。写这篇文章的目的不是教如何使用 Nuxt.js 或学习其相关的一些知识。只是从 Nuxt.js 是如何解决各种开发中的问题来分享一些前端架构方面的想法。当然，如果对以下知识点有所了解更能加深对本文的认识。

- [Nuxt.js](https://zh.nuxtjs.org/)
- [Vue](https://cn.vuejs.org) + [Vuex](https://vuex.vuejs.org/zh-cn/) + [Vue-router](https://router.vuejs.org/zh-cn/) + [Vue-ssr](https://ssr.vuejs.org/zh/)
- [Webpack](https://webpack.github.io/) + [Babel](https://babeljs.io/)

## 解决方案 & 框架

解决某一类通常遇到的问题的一系列方法，可以称为 `解决方案`，很多人也会称之为 `框架`。而问题解决的方式以及最后预期的产出将决定这个解决方案的最终形态，引入一段 Nuxt.js 官方的一段定义：

> Nuxt.js 是一个基于 Vue.js 的通用应用框架。
> 通过对客户端 / 服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI 渲染。
> 我们的目标是创建一个灵活的应用框架，你可以基于它初始化新项目的基础结构代码，或者在已有 Node.js 项目中使用 Nuxt.js。

我们可以理解为，Nuxt.js 主要是解决 Web 应用 UI 渲染的一种 `解决方案`。

解决方案存在的意义是帮助使用解决方案的开发者避免复杂重复的工作，绝大多数时候已经帮助开发者完成了大量与业务不相关的工作，或者避免一些容易出错的坑的解决方案的集成。对使用解决方案的开发者来说。

通常解决方案基本具备以下几个要素：

- 对使用的开发者透明（无需知道框架内部的具体实践就可以使用）。
- 基于某种或多种底层技术选型做的上层抽象封装。
- 提供配置、插件机制或 API 使得框架和具体业务实现分离解耦。
- 有一定学习成本（在框架的基础上二次开发具体业务）

而 Nuxt.js 在这三方面做的都比较优秀，使用者不了解 Nuxt.js 的内部源码同样可以使用。Nuxt.js 的内部使用 Vue, Babel, Webpack 等做为底层技术选型支撑上层框架，并且实现了具体业务的解耦，使用 Nuxt.js 可以独立的开发业务，只需要修改配置以及使用 Nuxt.js 提供的自定义组件或 API 就能完成特定业务的开发。

所有的通用解决方案或框架都有一个共同的目标：**提升开发者的开发效率**。

## 解决方案类型

工程化的解决方案做为解决问题的方法，是个抽象的概念，从解决问题的场景大致可以分为以下两种：

- Runtime 时候的问题
- 工程化开发、构建、调试时候的问题

有的时候一个完整的解决方案可能会考虑多种场景，也可能会专注于解决某一个单一问题场景的问题，例如 jQuery 就是专注解决 Runtime 时候的问题。而 Nuxt.js 所依赖的 Vue 则是解决了多个问题场景，Vue 的核心是解决了 Runtime 的 ui 渲染问题，并且解决方案衍生到了工程化脚手架，开发，构建调试等，甚至浏览器 Chrome DevTool 调试方案等。

然而要是从解决方案解决的具体问题的角度来划分类型的话，种类就繁杂多了，NPM 上发布的 package 都是解决某类特定问题的小型解决方案。虽然解决方案繁多，但是优秀的解决方案是需要集成一些优秀的设计思想，后面我们会深入的探讨下设计方面的东西。

## 架构设计

需要如何做才能设计出一个好的解决方案呢？需要怎么设计才能让使用解决方案的开发者更好的解决开发中遇到的问题呢？

很多前端领域或者其他领域的初学者，非常有激情并且乐于发现问题总结问题，然后写一些库、工具等小的解决方案。这固然是一个好的事情，可是往往写出的东西很难被广泛使用起来，甚至都没法用，而像 Nuxt.js 这样的解决方案为什么那么容易就被大家接受和使用上了呢？其中并不是说初学者们没有找到问题或者没有解决问题，而是没有很好的设计这些解决方案，导致别的开发者很难方便的去解决问题，这样就很有必要讲讲架构设计了。

### 抽象

需求往往是真实的，

### 模块化

无论是代码架构，还是产品设计，首先最基础的准则是将设计模块化，早期的 js 代码直接堆在某个文件中，充满着全局变量的代码是没有办法谈论任何架构设计的。一般模块化的粒度为 **专门实现具体某一个功能**，模块可能有自己的输入，也可能有自己的输出，但是模块内部肯定是完成了某一项特定的功能。面向对象的软件工程中模块通常是一个对象或 Class。可以大致的理解为，一个模块如下图所示：

![5](https://user-images.githubusercontent.com/3365978/29546944-bb8fbd9e-8729-11e7-9a67-cce448c4b95f.png)

Web 前端 JS 方面的模块化也不例外，随着 ES6 的普及，JS 几乎就是个完整的面向对象的语言了，所以我们在前端架构方面，模块化首先是我们要做的最基础的设计。对于 AMD, CMD, UMD 这些模块化的概念，就不在这里赘言了，可以自行了解。

### 高内聚

### 低耦合

如下图就是一个非常糟糕的高耦合设计，右侧的业务模块严重依赖左侧的底层模块，业务模块的改动很有可能涉及到整体的底层模块的改动。

![一个耦合的模型](https://user-images.githubusercontent.com/3365978/29525185-6f50e3fa-86c4-11e7-9108-8cdd9358f356.png)

如果上图还不够深刻，那么我们设想一个这样的场景：

> 当你使用一套 UI 组件的时候，需要你去修改组件的源代码来达到你的需求是一件很让人头疼的事情吧？或者，当你使用 Nuxt.js 的时候假如需要改

### 解耦

解耦是一个比较有意思的话题，解耦的好处是可以让开发者能够 **既享受解决方案带来的便利，又使业务逻辑脱离解决方案本身的束缚**。

### SOLID 设计原则

#### 单一责任原则

单一责任原则（Single Responsibility Principle - SRP）

电脑是由 CPU，内存条，显示器，鼠标，键盘等组成的一个机器，这在设计上就是一个很好的模块化的实践，每一个模块都单一的负责自己的事情，以及可以独立的拆装，甚至在相同的接口标准下，可以随意的更换不同品牌的模块。

#### 开放封闭原则

开放封闭原则（Open-Closed Principle - OCP）

简单讲就是在设计模块的时候严格的限制模块对外的暴露 API 或对象，继承于模块是开放（open）的，但是修改模块内部是封闭（close）的，所以模块需要尽量被设计成可继承的。

### 可插拔设计

### 插件化


## 配置驱动

### 完全解耦？

### 开发者想要的绝对不是源代码

### 清晰且细致的配置接口永远受待见

### 优雅的想象力

## 学习成本和约束

### DSL

### 无规矩不成方圆

### 天下不会掉馅饼

## 可维护性

可维护性一个重要的判断指标在于，能否支持扩展以及非 Nuxt.js 项目顺利接入 Nuxt.js。我们知道 Nuxt.js 是z

## 开源 & 生态

### 分享和学习

### 鼓励参与

### 生态建设

## 写在最后

Nuxt.js 仅仅是个专注于解决 Vue SSR 渲染和 Vue-router 相关的问题，也许并没有做到以上所说的全面。