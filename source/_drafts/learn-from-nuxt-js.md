---
title: 从 Nuxt.js 学习到了些什么？
catalog: true
subtitle: 窥探前端工程化解决方案的架构思路
header-img: lego-header.jpg
tags:
- 架构
- 开源
- Vue

categories:
- 架构
---

本文内容偏理论，比较枯燥乏味，慎读。

这段时间由于工作需要，对 Nuxt.js 这个框架进行了一些深入的研究，从中学习到了一些东西，所以写下来分享一下。我本人对 Nuxt.js 高度认可，我甚至觉得这种前端工程化的解决方案的架构模式正是我们所需要去学习和借鉴的一种非常优秀的实践。写这篇文章的目的不是教如何使用 Nuxt.js 或学习其相关的一些知识。只是从 Nuxt.js 是如何解决各种开发中的问题来探讨一些架构方面的想法。如果对以下知识点有所了解更能加深对本文的认识。

- [Nuxt.js](https://zh.nuxtjs.org/)
- [Vue](https://cn.vuejs.org) + [Vuex](https://vuex.vuejs.org/zh-cn/) + [Vue-router](https://router.vuejs.org/zh-cn/) + [Vue-ssr](https://ssr.vuejs.org/zh/)
- [Webpack](https://webpack.github.io/) + [Babel](https://babeljs.io/)

## 解决方案

解决某一类通常遇到的问题的一系列方法，可以称为 `解决方案`，很多人也会称之为 `框架`。而问题解决的方式以及最后预期的产出将决定这个解决方案的最终形态，引入一段 Nuxt.js 官方的一段定义：

> Nuxt.js 是一个基于 Vue.js 的通用应用框架。
> 通过对客户端 / 服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI 渲染。
> 我们的目标是创建一个灵活的应用框架，你可以基于它初始化新项目的基础结构代码，或者在已有 Node.js 项目中使用 Nuxt.js。

我们可以理解为，Nuxt.js 主要是解决 Web 应用 UI 渲染的一种 `解决方案`。

解决方案存在的意义是帮助使用解决方案的开发者避免复杂重复的工作，绝大多数时候已经帮助开发者完成了大量与业务不相关的工作，或者避免一些容易出错的坑的解决方案的集成。对使用解决方案的开发者来说。

通常解决方案基本具备三要素：

- 是对使用者透明（无需知道框架内部的具体实践）。
- 基于某种或多种底层技术选型。
- 提供配置、插件机制或 API 使得框架和具体业务实现分离解耦。

而 Nuxt.js 在这三方面做的都比较优秀，使用者不了解 Nuxt.js 的内部源码同样可以使用。Nuxt.js 的内部使用 Vue, Babel, Webpack 等做为底层技术选型支撑上层框架，并且实现了具体业务的解耦，使用 Nuxt.js 可以独立的开发业务，只需要修改配置以及使用 Nuxt.js 提供的组件或 API 就能完成特定业务的开发。

然而，所有的通用解决方案或框架都有一个共同的目标：**提升开发效率**。

## 解决方案形态

工程化的解决方案做为解决问题的方法，是个抽象的概念，那么在开发中，通常是以什么形态存在的呢？这需要区分解决的是一些什么问题，大致可以分为以下几种问题。

- Runtime 时候的问题
- 工程化开发和构建的问题
- Debug 时候的问题

有的解决方案专注的解决某一类问题，有的解决多类问题，有的解决方案会解决开发过程中的所有问题。这个取决于解决方案本身的定位，解决的问题类别不同，存在的形态自然也不同。

Nuxt.js 做为一种前端 UI 渲染框架，解决的主要问题是开发和构建的问题。Runtime 和 Debug 的问题其实交给了底层的 Vue 全家桶和 Webpack 去做。

### Node.js package

解决工程化开发和构建方面问题的解决方案，通常会需要在本地对工程进行编译构建，由于 Nuxt.js 自定义了一套 config 规则和 Vue like API，正常直接使用底层依赖跑是跑不起来的，所以才有 nuxt 系列的命令行工具帮助开发者进行一系列的开发和构建，以至于将 Nuxt.js 自定义的部分都编译为底层可以跑起来的代码（Nuxt.js 比较巧妙，将自定义语法编译后，再使用底层的 Webpack 编译成真正可以 Run 的代码）。

所以，这种线下编译构建的解决方案，会将整个编译的过程封装成一个 NPM 包，在使用 Node.js 编译的时候可以直接 install 使用命令行或者 API，当然，不局限于 Node.js 也可以将这类的构建的工具封装成其他的编译脚本语言的 package 。

当然，不能粗粒度的这么完全划分开，Nuxt.js 除了提供 NPM 包，还需要将自定义 DSL(后面会讲到) 以及自定义文件目录、API 等优雅的暴露给开发者，才形成了完整的一套解决方案。

### Lib

### DevTools

## 解耦

通常会有这么一种场景：

> 某解决方案导出的工程中内置了某个 ui 库, 然后这个 ui 库耦合延伸到了工程公共模块暴露的 API, 然后要求使用这个解决方案的开发者必须要熟悉并且使用这个 ui 库, 哪怕开发者熟悉并且喜爱的是另一个 ui 库，只要你还使用这套整体解决方案的话，也只能强制使用这个 ui 库，要不然开发者自己去改解决方案底层代码，坦白说，这样的设计就很操蛋了。

### 低耦合，高内聚

### 越底层，越独立

### 剥离所有第三方依赖性

## 模块化

### 可插拔设计

### 乐高

### 插件化

## 配置驱动

### 开发者想要的绝对不是源代码

### 清晰且细致的配置接口永远受待见

### 优雅的想象力

## 约束和学习成本

### DSL

### 无规矩不成方圆

### 天下不会掉馅饼

## 可维护性

可维护性一个重要的判断指标在于，能否支持扩展以及非 Nuxt.js 项目顺利接入 Nuxt.js。我们知道 Nuxt.js 是z

## 开源 & 生态

## 写在最后

Nuxt.js 仅仅是个专注于解决 Vue SSR 渲染和 Vue-router 相关的问题，也许并没有做到以上所说的全面。