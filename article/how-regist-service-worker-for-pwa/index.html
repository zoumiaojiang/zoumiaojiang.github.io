<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="baidu-site-verification" content="aUkeDDBeAZ" />
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="这是一篇技术文，在开始阅读这篇文章之前，先了解以下内容更能加深您的理解：

PWA
Service worker 的工作原理

这篇文章主要探讨的是如何让 PWA 优雅合理的注册一个 Service Worker，从而让站点拥有 Service Worker 所提供的能力，如果看到标题的第一想法是 “Service Worker 注册一个这么简单的话题有啥可讲的”，看到后面可以发现还是有一些...">
    <meta name="keyword"  content=" PWA, Service Worker, Lavas">
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#000000">
    <!-- Add to home screen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Peace">
    <link rel="apple-touch-icon" href="/img/icons/icon-152x152.png">
    <link rel="shortcut icon" href="/img/zoumiaojiang.ico">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script>
        var targetProtocol = 'https:';
        if (location.protocol !== targetProtocol && location.host === 'zoumiaojiang.com') {
            location.href = targetProtocol + location.href.substring(location.protocol.length);
        }
    </script>
    
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <title>
        
          如何优雅的为 PWA 注册 Service Worker - zoumiaojiang
        
    </title>

    <link rel="canonical" href="https://zoumiaojiang.com/article/how-regist-service-worker-for-pwa/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
<link rel="stylesheet" href="/css/zoumiaojiang.min.css">

    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    
<link rel="stylesheet" href="/css/widget.css">


    
<link rel="stylesheet" href="/css/rocket.css">


    
<link rel="stylesheet" href="/css/signature.css">


    
<link rel="stylesheet" href="/css/toc.css">


    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.0"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">
	<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('service-worker.png')
            /*post*/
        
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#PWA" title="PWA">PWA</a>
                            
                              <a class="tag" href="/tags/#Service Worker" title="Service Worker">Service Worker</a>
                            
                              <a class="tag" href="/tags/#Lavas" title="Lavas">Lavas</a>
                            
                        </div>
                        <h1>如何优雅的为 PWA 注册 Service Worker</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by zoumiaojiang on
                            2017-07-30
                        </span>
                    </div>
                


                </div>
            </div>
        </div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Peace</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">
                <p>这是一篇技术文，在开始阅读这篇文章之前，先了解以下内容更能加深您的理解：</p>
<ul>
<li><a href="https://lavas.baidu.com/doc" target="_blank" rel="noopener">PWA</a></li>
<li><a href="https://lavas.baidu.com/doc/offline-and-cache-loading/service-worker/service-worker-introduction" target="_blank" rel="noopener">Service worker 的工作原理</a></li>
</ul>
<p>这篇文章主要探讨的是如何让 PWA 优雅合理的注册一个 Service Worker，从而让站点拥有 Service Worker 所提供的能力，如果看到标题的第一想法是 “Service Worker 注册一个这么简单的话题有啥可讲的”，看到后面可以发现还是有一些坑的。本文少图较长，慎读。</p>
<p>通过对 PWA 文档的学习和理解，我们应该都知道了 PWA (Progressive Web Apps) 不是一项技术，不是一个框架，如果我们非要说 PWA 是个什么，可以把她理解为一种模式，一种通过应用一些技术将 Web App 在安全、性能和体验等方面带来渐进式的提升的一种 Web App 模式。如果对 PWA 进行一个简单粗粒度的拆解的话，她主要包含三个方面：</p>
<ul>
<li>可靠 - 即使在不稳定的网络环境下，也能瞬间加载并展现</li>
<li>体验 - 快速响应，并且有平滑的动画响应用户的操作</li>
<li>粘性 - 像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到桌面</li>
</ul>
<p>作为一个开发者，也许更关心是通过怎样的技术来怎么实现这三个方向的功能特性。通过前面的 Service Worker 文档链接学习，大家应该知道 Service Worker 具有离线缓存（Offline Cache），消息推送（Notification Push），后端同步（Background sync）的能力。在弱网环境下快速加载，Service Worker 的离线缓存功能功不可没，以及在其他体验优化和提升用户粘性方面 Service Worker 都发挥着重要的作用。</p>
<h2>Service Worker 文件</h2>
<p>您可能已经了解了 Service Worker，但是这里还是有必要再简单的探讨一下什么是 Service Worker，对于浏览器来说，Service Worker 是一个独立于 js 主线程的一种 Web Worker 线程，一个独立于主线程的 Context，但是面向开发者来说 Service Worker 的形态其实就是一个需要开发者自己维护的文件，我们假设这个文件叫做 <code>sw.js</code>，此文件的内容就是定制 Service Worker 生命周期中每个阶段所处理的定制化的细节逻辑，比如缓存 Cache 的读写，更新的策略，推送的策略等等，通常 <code>sw.js</code> 文件是处于项目的根目录，并且需要保证能直接通过 <code>https://yourhost/sw.js</code> 这种形式直接被访问到才行。</p>
<p>当然，如果快速写一个 <code>sw.js</code> 用来注册玩一下而已还是蛮简单的，基本就是如下的套路（代码为示意代码）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sw.js 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 安装</span></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存 App Shell 等关键静态资源和 html (保证能缓存的内容能在离线状态跑起来)</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活</span></span><br><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 激活的状态，这里就做一做老的缓存的清理工作</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存请求和返回（这是个简单的缓存优先的例子）</span></span><br><span class="line">self.addEventLisener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.respondWith(caches.match(e.request)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (response) &#123;</span><br><span class="line">                <span class="keyword">return</span> response;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// fetchAndCache 方法并不存在，需要自己定义，这里只是示意代码</span></span><br><span class="line">            <span class="keyword">return</span> fetchAndCache(e.request);</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通常开发者都不太愿意从无到有去自己写一个 <code>sw.js</code> 的，一般都会选择使用工具来辅助生成一个相对复杂和完善的 Service Worker 文件，例如 <a href="https://github.com/GoogleChrome/sw-precache" target="_blank" rel="noopener">sw-precache</a> + <a href="https://github.com/GoogleChrome/sw-toolbox" target="_blank" rel="noopener">sw-toolbox</a> 组合的方式，这样的话就省去了其中的很多缓存策略的细节考虑以及细节逻辑处理问题。当然，Service Worker 文件如何生成不是我们今天所要讲的重点话题。假设在正式开始我们今天的主题之前已经生成好了一份 <code>sw.js</code> 文件了，接下来就深入的探讨一下如何优雅的去注册一个已经生成好的 <code>sw.js</code>。</p>
<h2>快速注册 Service Worker</h2>
<p>注册 Service Worker 还是蛮简单的，只要小段代码。只要在工程中的 html 文档的 <code>&lt;script&gt;</code> 里或者随便在页面的哪个 javaScript 模块中加如下这行代码就搞定了，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只要保证 https://yourhost/sw.js 可访问就行</span></span><br><span class="line"><span class="keyword">if</span> (navigator.serviceWorker) &#123;</span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'/sw.js'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 Service Worker 的载入是完全异步的（Chrome DevTools 中 Network 的 XHR 中可以找到），注册的时候不用担心 block 的问题。</p>
<p>理想很丰满，现实太骨感，生产环境下的 Web App 开发中如果真是这么简单的话就好了，那在这里就没必要来写这篇文章。这句代码的确能注册 Service Worker，但是 Service Worker 注册这个看似简单的工作远比我们想象的要复杂。接下来一点一点的来深入。</p>
<h2>HTTPS 环境</h2>
<p>HTTPS 是 Service Worker 所必须依赖的应用层协议，Service Worker 只有在 Web App 为 HTTPS 的环境下才能被注册成功，可是我们开发的时候应该不会直接在线上开发，拥有一个 HTTPS 的测试环境成本很高。</p>
<p>各大浏览器厂商也考虑到了这个问题，如 Chrome，Firefox，在 <code>localhost</code> 和 <code>127.0.0.1</code> 的 host 下，也能注册成功。这样就能保证我们在本地开发的时候也能直接注册。</p>
<p>对于很多开发者来说，大部分情况是有自己的开发环境的机器，但是没有配置 HTTPS，可以通过改 host 的方式来将远程的 IP 对应到 <code>localhost</code> 的域就可以了，这样既能保证访问到的是真实的开发环境，并且不用费很大劲去弄 HTTPS 环境的把 Service Worker 给注册了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /private/etc/hosts 或 /windows/system32/drivers/etc/hosts</span></span><br><span class="line"><span class="comment"># 开发环境 IP 为 12.23.34.45</span></span><br><span class="line"></span><br><span class="line">12.23.34.45  localhost</span><br></pre></td></tr></table></figure>
<p>对于远程开发环境还可以通过本地服务器（nginx 或 apache 等）代理的方式去做，在这里就不做深入的探讨。</p>
<h2>Service Worker 作用域</h2>
<p>通常情况下，在注册 <code>sw.js</code> 的时候会忽略 Service Worker 作用域的问题，Service Worker 默认的作用域就是注册时候的 path, 例如 Service Worker 注册的 path 为 <code>/a/b/sw.js</code>，则 scope 默认为 <code>/a/b/</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (navigator.serviceWorker) &#123;</span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'/a/b/sw.js'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">reg</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(reg.scope);</span><br><span class="line">        <span class="comment">// scope =&gt; https://yourhost/a/b/</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也可以通过在注册时候传入 <code>{scope: '/some/scope/'}</code> 参数的方式自己指定 scope ，但是自己指定 scope 也是有一定的限制的，其中也隐藏着一些坑。</p>
<p>当合理的指定 scope 的情况下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (navigator.serviceWorker) &#123;</span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'/a/b/sw.js'</span>, &#123;<span class="attr">scope</span>: <span class="string">'/a/b/c/'</span>&#125;)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span> (<span class="params">reg</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(reg.scope);</span><br><span class="line">            <span class="comment">// scope =&gt; https://yourhost/a/b/c/</span></span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是也存在指定错误的 scope 的情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (navigator.serviceWorker) &#123;</span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'/a/b/sw.js'</span>, &#123;<span class="attr">scope</span>: <span class="string">'/a/'</span>&#125;)</span><br><span class="line">        .then(<span class="function"><span class="keyword">function</span> (<span class="params">reg</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(reg.scope);</span><br><span class="line">            <span class="comment">// Ops !!!，报错啦！！</span></span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/3365978/28677362-e64ae220-731f-11e7-9068-de31ca390211.png" alt="scope 报错信息"></p>
<p>通过报错信息，可以知道 <code>sw.js</code> 文件是在 <code>/a/b/</code> path 下才能被访问到，则默认的 scope 和最大的 scope 都是 <code>/a/b/</code> 通俗的讲：Service Worker 最多只能在这个 path 范围内发挥作用，以代码为例，<code>/a/b/</code>，<code>/a/b/c/</code>，<code>/a/b/c/d/</code> 下的页面都可以被注册的 Service Worker 控制，但是 <code>/a/</code>，<code>/e/f/</code> 下面的页面是不受注册的 Service Worker 的控制的（当然浏览器也会抛出错误告知开发者）。</p>
<p>也就是说，在最大 scope 的基础上才能指定自定义的 scope， 例如 <code>/a/b/c/</code> 。</p>
<blockquote>
<p>值得注意的是：</p>
<p>类似于 Ajax 的跨域请求可以通过对请求的 <code>Access-Control-Allow-Origin</code> 设置，我们也可以通过服务器对 <code>sw.js</code> 这个文件的请求头进行设置，就能够突破 scope 的限制，只需要设置 <code>Service-Worker-Allowed</code> 为更大控制范围或者其他控制范围的 scope 即可。</p>
</blockquote>
<p>通过对 Service Woker 作用域的了解，也许会发现这么样的一个问题：</p>
<p>假设在 <code>https://yourhost</code> 域下有 A 页面 (<code>https://yourhost/a</code>) 和 B 页面（<code>https://yourhost/b</code>）。</p>
<p>假设 A 页面在 <code>/a/</code> 作用域下注册了一个 Service Worker，B 页面在 <code>/</code> 作用域下注册了一个 Service Worker，这种情况下 B 页面的 Service Worker 就可以控制 A 页面，因为 B 页面的作用域是包含 A 页面的最大作用域的（我们可以把这种情况称之为 <code>作用域污染</code>）。在开发环境开发者还可以通过 DevTools 进行手动 unregister 来清除掉污染的 Service Worker，但是如果用户在手机端被安装了 Service Worker 之后可以理解这就是个持久的过程。除非用户手动清除存储的缓存（这个也是不可能的），否则对用户来说就是个持久污染的噩梦。</p>
<p>当然，出现作用域污染的情况也不是没有办法补救的，比较合理的一种做法是，在新上线的版本中注册 Service Worker 之前将污染的 Service Worker 注销掉。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (navigator.serviceWorker) &#123;</span><br><span class="line">    navigator.serviceWorker.getRegistrations().then(<span class="function"><span class="keyword">function</span> (<span class="params">regs</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> reg <span class="keyword">of</span> regs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (reg.scope === <span class="string">'https://yourhost/'</span>) &#123;</span><br><span class="line">                reg.unregister();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注销掉污染 Service Worker 之后再重新注册自己作用域的 Service Worker</span></span><br><span class="line">        navigator.serviceWorker.register(<span class="string">'/a/sw.js'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">reg</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于一个拥有多个平行子站的大型站点，作用域污染的情况很有可能因为缺乏沟通或者滥用 Service Worker 而发生。</p>
<h2>SPA 注册 Service Worker</h2>
<p>SPA（Single Page Applications），单页 Web 应用，在工程架构上只有一个 <code>index.html</code> 的入口，站点的内容都是异步请求数据之后在前端渲染的，应用中的页面切换都是在前端路由控制的。</p>
<p>通常会将这个 <code>index.html</code> 部署到 <code>https://yourhost</code>，对于 SPA 的 Service Worker，只会在 <code>index.html</code> 中注册一次，所以我们会将 <code>sw.js</code> 直接放在站点的根目录保证可访问，Service Worker 的 scope 通常就是 <code>/</code>，这样能够控制整个 SPA 的缓存。</p>
<p>SPA 每次路由的切换都是前端渲染的过程，本质上还是在 <code>index.html</code> 上的前端交互，通常 Service Worker 会缓存 SPA 中的 AppShell 所需的静态资源和 <code>index.html</code>。当然有一种情况比较特殊，当用户从 <code>/a</code> 页面切换到 <code>/b</code> 页面，然后这时候刷新页面，此时首先渲染的还是 <code>index.html</code>，在执行 SPA 的路由逻辑之后，通过 SPA 前端路由的处理继续在前端渲染相应的路由对应的 Component。</p>
<h2>MPA 注册 Service Worker</h2>
<p>MPA（multi page applications），多页应用，这种架构的模式在现如今的大型站点非常常见，例如 <a href="https://m.ele.me" target="_blank" rel="noopener">ele.me</a> 就是采用这种模式来架构的站点，这种站点有常规的 Web App 的特性，但是相比较 SPA 能够承受更重的业务体量，并且利于大型站点的后期维护和扩展。针对 MPA 的 PWA 可以阅读 <a href="https://zhuanlan.zhihu.com/p/27853228" target="_blank" rel="noopener">饿了么的 PWA 升级实践</a> 进行更加深入了解。</p>
<p>在这里我们可以更加深入的了解一下 MPA PWA 是如何注册 <code>sw.js</code> 的，MPA 可以理解为是有多个 html 文件对应着多个不同的服务端路由，也就是说 <code>https://yourhost/a</code> 映射到 <code>a.html</code>, <code>https://yourhost/b</code> 映射到 <code>b.html</code> 等等。</p>
<p>那么这种架构下怎么去注册 Service Worker 呢？是不同的页面注册不同的 Service Worker，还是所有的页面都注册同一个 Service Worker？结论是：需要根据实际情况来定。</p>
<h3>注册单个 Service Worker</h3>
<p>在每个页面之间的业务相似度较高，或者每个页面之间的公共静态资源或异步请求较多，这种 MPA 是非常适合在所有的页面只注册一个 Service Worker。</p>
<p>例如 <code>https://yourhost/a</code> 和 <code>htps://yourhost/b</code> 之间的公共内容较多，则通常情况下在 <code>/</code> 作用域下注册一个 Service Worker。这样这个 Service Worker 能够控制 <code>https://yourhost</code> 域下的所有页面。</p>
<p>维护单个 Service Worker 有如下特点：</p>
<ul>
<li>可以统一管理整个站点的缓存。</li>
<li>不会造成页面之间的作用域污染。</li>
<li>后期维护成本相对较低。</li>
</ul>
<h3>注册多个 Service Worker</h3>
<p>适用于主站非常庞大，并且是以 path 分隔的形式铺展垂类子站的大型站点（现在这种毕竟少了，基本都用二级域名区分子站），这种情况下不适合只在跟作用域下注册一个 Service Worker。</p>
<p>例如，<code>https://yourhost/a</code> 和 <code>https://yourhost/b</code> 几乎是两个站点，其中公共使用的静态资源或异步请求非常少，则比较适合每个子站注册维护自己的 Service Worker，<code>https://yourhost/a</code> 注册 Servcie Worker 的作用域为 <code>/a/</code>，最好是存在 <code>/a/sw.js</code> 可访问，尽量不要使用某一个公用的 <code>/sw.js</code> 然后使用 <code>scope</code> 参数来自定义作用域。这样会增加后期的维护成本以及增加出现 bug 的几率。</p>
<p>子站在实现上还要考虑一点是，防止主站 <code>https://yourhost</code> 的 Service Worker 对自身造成污染，需要在注册子站 Service Worker 之前将主站的 Service Worker 注销掉（这个方法也不是很好，相当于剥夺了主站 Service Worker 的权利）。</p>
<p>注册多个 Service Worker 有如下特点：</p>
<ul>
<li>需要严格要求每个子站管理好自己的 <code>sw.js</code> 以及 scope。</li>
<li>防止对其他子站的 Service Worker 造成影响。</li>
<li>相比较整个站点只注册一个 Service Worker，这种维护多个 Service Worker 的方式更加灵活。</li>
<li>风险相对会更加大，也更加难以维护。</li>
</ul>
<h2>Service Worker 更新</h2>
<p>Service Worker 的更新也会影响到 Service Worker 的注册，在这里，重点剖析一下 Service Worker 更新的问题。</p>
<p>当页面注册好了一个 Service Worker 之后，Service Worker 会被安装、激活、通过 <code>fetch</code> 事件监听作用域下站点的网络请求等等行为，为了 Web App 的首屏体验，<a href="https://lavas.baidu.com/doc/architecture/the-app-shell-model" target="_blank" rel="noopener">AppShell</a> 作为最小优先展现单元，其中的html 页面和静态资源是需要被持久缓存起来的。也就是说保证用户能在离线之后至少优先看到一个完整的 AppShell。</p>
<p>这个和优雅的注册 Service Worker 有个啥子关系？</p>
<p>拿 SPA 为例，作为 AppShell 的载体 <code>index.html</code> 是会被缓存起来的，AppShell 的静态资源也都会被缓存起来的，然而 Service Worker 的注册必然是需要在 <code>index.html</code> 的 <code>&lt;script&gt;&lt;/script&gt;</code> 标签或者被缓存住的 js 文件中做的。</p>
<p>如果 <code>sw.js</code> 发生了更新，我们预期的是希望浏览器立即更新当前页面的缓存，并且立即加载最新的内容和资源。<code>sw.js</code> 的更新包含她 URL 的更新和内容的更新，Service Worker 本身的机制能够 diff 到 <code>sw.js</code> 的更新，如果在注册时候通过 <a href="https://w3c.github.io/ServiceWorker/#update-algorithm" target="_blank" rel="noopener">Service Worker Update 算法</a> diff 到 URL 或者 内容的更新，则马上启动新的 <code>sw.js</code> 文件的安装、激活，但因为用户当前的页面已经使用老的缓存中的内容加载完成，所以需要等到第二次进入页面的时候才能真正使用新的静态资源和网络请求。</p>
<p>这个机制是有以下两个坑的：</p>
<ul>
<li><code>sw.js</code> 自身也会被浏览器缓存（也就是 diff 不能做到实时）</li>
<li>就算 diff 到了最新的 <code>sw.js</code>，用户在当前的这次访问中的任何交互还是使用老的缓存内容，需要等到第二次进入页面才能更新缓存</li>
</ul>
<p>对于 <code>sw.js</code> HTTP 缓存的问题解决方案肯定是让这个文件永远都不缓存（暂时不讨论请求开销的问题）</p>
<h2>Service Worker 文件 no-cache 处理</h2>
<p>为了能让 Service Worker 做到实时更新，必须要解决 Service Worker 文件 <code>sw.js</code> HTTP 缓存的问题。<br>
通常需要让文件完全无缓存，有两种思路：一种是在服务器端控制请求文件的 <code>Cache-Control</code>，另一种就是在前端通过版本号来改变浏览器缓存策略。</p>
<h3>服务器 Cache-Control</h3>
<p>服务器端的 Cache-Control 的控制是将 <code>sw.js</code> 的请求设置成 <code>no-cache</code>，以 nginx 为例：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ \/sw\.js$</span> &#123;</span><br><span class="line">    <span class="attribute">add_header</span> Cache-Control <span class="literal">no</span>-store;</span><br><span class="line">    <span class="attribute">add_header</span> Pragma <span class="literal">no</span>-cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过配置服务器这种方式的<strong>好处</strong>是：只要做好了 <code>sw.js</code> 缓存实时更新问题之后，就可以不用关心整个 Web App 的实时更新问题，浏览器都会参照 「<code>sw.js</code> 的 diff」 -&gt; 「重新安装新 <code>sw.js</code>」 -&gt; 「激活并删除老的缓存」 -&gt;「用户第二次进入页面重新更新缓存」的套路来自行搞定。</p>
<p>当然，这种处理方式也有很大的局限性，如果您将静态资源都部署在第三方的 CDN 静态资源服务器，单独针对某一个文件进行服务器设置 <code>sw.js</code> 还是感觉很麻烦。尤其是对于大型站点的运维人员来说，在服务器新增一个路由不是一件很随意的事情。</p>
<h3>前端版本控制</h3>
<p>对于前端版本控制，前端开发者应该并不陌生，如果需要一个静态资源的请求永远不会被缓存，下面这种做法就很好理解了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (navigator.serviceWorker) &#123;</span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'/sw.js?v='</span> + <span class="built_in">Date</span>.now());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码一祭出，就解决了之前所提到的 <code>sw.js</code> 被浏览器缓存的问题了。</p>
<p>但是，这种做法又引发出了其他的问题，每次执行注册 Service Worker 代码逻辑的时候，Service Worker 都能 diff 到变化（URL 的变化也是一种更新的 diff），每次都会在第一次安装，第二次激活并且更新缓存，这种做法使得 Service Worker 的缓存完全没有生效，和每次都和请求最新的 Network 请求内容没什么区别，理论上讲，这种方式由于缓存的频繁读取和删除，甚至比每次直接无缓存刷新的性能更加糟糕。</p>
<blockquote>
<p>在这里也需要提醒大家注意</p>
<p>在 Service Worker 得注册过程中，慎用时间戳来做版本控制，会导致一些意想不到的坑。事实也证明这种做法也是不可取的。</p>
</blockquote>
<p>接下来转变一下思路，这个时候需要先想一想如何优雅的做好无缓存的版本控制了。如果不能对 <code>sw.js</code> 直接做版本控制，能不能对别的文件做无缓存的版本控制，然后在这个文件中再执行 Service Worker 的注册逻辑？</p>
<p>假设这个文件叫 <code>sw-register.js</code>，其代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sw-register.js</span></span><br><span class="line"><span class="keyword">if</span> (navigator.serviceWorker) &#123;</span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'/sw.js'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">reg</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 <code>index.html</code> 中对 <code>sw-register.js</code> 做版本控制就好了：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> firstScript = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'script'</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="actionscript">        script.type = <span class="string">'text/javascript'</span>;</span></span><br><span class="line"><span class="actionscript">        script.async = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">        script.src = <span class="string">'/sw-register.js?v='</span> + <span class="built_in">Date</span>.now();</span></span><br><span class="line">        firstScript.parentNode.insertBefore(script, firstScript);</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样处理之后，<code>sw-register.js</code> 就不会被浏览器缓存了，并且由于 <code>sw-register.js</code> 是异步加载的，也不会造成页面 block，但还有个问题，当前的 <code>sw.js</code> 依然会被浏览器 HTTP 缓存。根本问题还是没有解决。</p>
<p>其实设想一下，每次 Service Worker 的更新都是因为工程的上线，如果能够保证每次上线一次就赋给 <code>sw.js</code> 一个版本，等新上线之后就用新的版本号替换老的版本号，从而触发 Service Worker 的 diff，并且能保证每次上线之后就更新了新的 <code>sw.js</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sw-register.js</span></span><br><span class="line"><span class="keyword">if</span> (navigator.serviceWorker) &#123;</span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'/sw.js?v=buildVersion'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">reg</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>buildVersion</code> 是每次上线前构建的一个唯一版本号。</p>
<p>这样看来，是解决了之前 Service Worker 更新不及时的问题。但是代价是增加了一次 <code>sw-register.js</code> 的请求，由于 <code>sw-register.js</code> 通常只做 Service Worker 的注册工作，体量不会太大，所以应该还是可以接受，相比于在服务器端的配置，前端的版本控制的方案应该更加的简单方便。</p>
<h3>为什么不直接使用 buildTime 做版本控制？</h3>
<p>绕了一圈，版本控制为什么不直接在 注册 <code>sw.js</code> 时候做，为什么非要借助一个 <code>sw-register.js</code> 文件？就像如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (navigator.serviceWorker) &#123;</span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'/sw.js?v=buildTime'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了保证离线可用，所有和 AppShell 相关的 html 和静态资源都要被缓存住，此时，就算上线时候更改了 <code>buildTime</code>, 但是 Service Worker 所有可能被注册的地方由于被缓存了是感知不到变化的，除非是用 <code>Date.now()</code> 这种变量时间戳的方式自动轮询，但是这种方案的弊端在前面已经分析过了。</p>
<h2>Service Worker 缓存实时生效</h2>
<p>Service Worker 是一个独立于浏览器主线程的 Worker 线程，在这个线程 Context 中是不允许操作页面的 DOM，但是 Worker 线程可以通过 postMessage 机制与主线程进行通信。</p>
<p>通过前面对 Service Worker 的介绍，已经了解到 Service Worker 更新的第二个痛点是必须要等到用户第二次进入页面的时候才能使用 Service Worker 更新之后的内容，我们的预期是如果 Web App 重新上线了，那用户在任何时候打开页面都能使用到最新的内容，并且同时还要保持 Service Worker 离线缓存的特性。</p>
<p>通过对 <code>sw.js</code> 文件的无缓存处理，我们能做到实时的检测更新，接下来需要处理缓存更新实时生效的问题。</p>
<p>当注册 Service Worker 得时候，实时监测到 <code>sw.js</code> 更新之后，则浏览器会立即立即安装、激活，然而激活完成并清除老的缓存之后，如果有一种途径告诉主线程 <code>sw 完成了更新</code> 这样也会对用户比较友好。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sw.js 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新的 Service Worker 更新时，进入激活状态后，会触发 activate 事件</span></span><br><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cacheName = <span class="string">'a_cache_name'</span>;</span><br><span class="line">    event.waitUntil(</span><br><span class="line">        caches.open(cacheName)</span><br><span class="line">            .then(<span class="function"><span class="keyword">function</span> (<span class="params">cache</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 进行老缓存的清除...(略过..)</span></span><br><span class="line">            &#125;)</span><br><span class="line">            .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 完成缓存删除之后就可以通知浏览器主线程啦</span></span><br><span class="line">                <span class="comment">// 当然这里也可以判断如果缓存内本来就没内容</span></span><br><span class="line">                <span class="comment">// 就代表是首次安装，就不要发 message了 (这个逻辑略过...)</span></span><br><span class="line">                <span class="keyword">return</span> self.clients.matchAll()</span><br><span class="line">                    .then(<span class="function"><span class="keyword">function</span> (<span class="params">clients</span>) </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (clients &amp;&amp; clients.length) &#123;</span><br><span class="line">                            clients.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">client</span>) </span>&#123;</span><br><span class="line">                                <span class="comment">// 给每个已经打开的标签都 postMessage</span></span><br><span class="line">                                client.postMessage(<span class="string">'sw.update'</span>);</span><br><span class="line">                            &#125;)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样的话，相当于我们在自己的业务代码中只要监听 <code>message</code> 事件，监听到 <code>sw.update</code> 这个 message 就知道 Service Worker 更新成功了。看来这段代码写在 <code>sw-register.js</code> 中比较优雅，我们可以把 <code>sw-register.js</code> 这个文件就当成专门处理 Service Worker 的文件好了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sw-register.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (navigator.serviceWorker) &#123;</span><br><span class="line">    navigator.serviceWorker.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e.data === <span class="string">'sw.update'</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果代码走到了在这里，就知道了，Service Worker 已经更新完成了</span></span><br><span class="line">            <span class="comment">// 可以做点什么事情让用户体验更好</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3>Service Worker 实时生效的策略</h3>
<p>通常对用户比较友好的实时生效策略有两种：</p>
<ul>
<li>监听到 Service Worker 成功更新后，直接 <code>location.reload()</code> 刷新当前页面</li>
<li>通过 toast 的形式提示用户主动刷新当前页面</li>
</ul>
<p>目前百度 <a href="https://lavas.baidu.com" target="_blank" rel="noopener">Lavas</a> 解决方案推荐的是第二种引导用户刷新的方式，<a href="https://www.flipkart.com/" target="_blank" rel="noopener">Filpkart Lite（墙外）</a> 也是使用引导用户的方式，当然随意添加 toast 可能会引起产品点击率等方面的影响，具体使用哪种策略当然是由产品设计师决定。我们在这里讲的是使用技术手段建立的这套机制。</p>
<p><img src="https://user-images.githubusercontent.com/3365978/28677486-2ed23d68-7320-11e7-8aad-8346e5134e90.png" alt="lavas Service Worker 更新完成提示"></p>
<h2>sw-register-webpack-plugin</h2>
<p>无论是 Service Worker 作用域问题，还是 Service Worker 的更新问题，都与 Service Worker 的注册息息相关，一个看似简单的 Service Worker 的注册还是有很多地方需要注意，但是如果这些都需要在每个项目中都要自己完全实现一遍，还是非常繁琐的。而 <a href="https://github.com/lavas-project/sw-register-webpack-plugin" target="_blank" rel="noopener">sw-register-webpack-plugin</a> 作为一个 Webpack Plugin 很好的帮助我们解决了 <strong>优雅的注册 Service Worker 的问题</strong></p>
<ul>
<li>如果项目是基于 Webpack 开发的</li>
<li>如果不希望自己考虑繁琐的 Service Worker 问题</li>
<li>无论是 SPA 还是 MPA</li>
</ul>
<p>基于以上的考虑，都可以尝试一下 sw-register-webpack-plugin</p>
<h3>安装</h3>
<p>在项目中引入 sw-register-webpack-plugin</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev sw-register-webpack-plugin</span><br></pre></td></tr></table></figure>
<h3>使用</h3>
<p>配置 Webpack 的配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SwRegisterWebpackPlugin = <span class="built_in">require</span>(<span class="string">'sw-register-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line">webpack(&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// ... some plugins</span></span><br><span class="line">        <span class="keyword">new</span> SwRegisterWebpackPlugin(&#123; <span class="comment">/* options */</span>&#125;)</span><br><span class="line">        <span class="comment">// ... some plugins</span></span><br><span class="line">    ]</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>参数介绍详见 <a href="https://github.com/lavas-project/sw-register-webpack-plugin/blob/master/README.md" target="_blank" rel="noopener">sw-register-webpack-plugin 在 github 中的介绍</a></p>
<blockquote>
<p>PS: 硬广</p>
<p>百度 Lavas 解决方案中关于 Service Worker 的解决方案采用的就是 sw-register-webpack-plugin</p>
<p>关于 <code>sw.js</code> 文件生成 Lavas 各个模版中采用的是 sw-precache-webpack-plugin 插件，底层使用的是 sw-precache + sw-toolbox 解决方案，Lavas 生成的 <code>sw.js</code> 在更新完成后会通过 <code>postMessage</code> 发送 <code>sw.update</code> 的消息。</p>
</blockquote>

                <p style="font-weight:bold;">欢迎大家扫码关注我的微信公众号「江哥乱谈」，关注我更多的文章动态。</p>
                <img src="/img/qrcode.jpg" style="border:none;">
                <blockquote>
                本文为原创文章，会经常更新知识点以及修正一些错误，因此转载请保留原出处，方便溯源，避免陈旧错误知识的误导，同时有更好的阅读体验。 <br/>
                转载请注明来源：<a href="https://zoumiaojiang.com/article/how-regist-service-worker-for-pwa/" rel="noopener" title="https://zoumiaojiang.com/article/how-regist-service-worker-for-pwa/">https://zoumiaojiang.com/article/how-regist-service-worker-for-pwa/</a>
                </blockquote>
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/article/how-to-build-a-blog/" data-toggle="tooltip" data-placement="top" title="快速低成本的搭建一个马马虎虎的博客">&larr; Previous Post</a>
                        </li>
                    
                    
                </ul>

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">Contents</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#"><span class="toc-nav-text">Service Worker 文件</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#"><span class="toc-nav-text">快速注册 Service Worker</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#"><span class="toc-nav-text">HTTPS 环境</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#"><span class="toc-nav-text">Service Worker 作用域</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#"><span class="toc-nav-text">SPA 注册 Service Worker</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#"><span class="toc-nav-text">MPA 注册 Service Worker</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">注册单个 Service Worker</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">注册多个 Service Worker</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#"><span class="toc-nav-text">Service Worker 更新</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#"><span class="toc-nav-text">Service Worker 文件 no-cache 处理</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">服务器 Cache-Control</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">前端版本控制</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">为什么不直接使用 buildTime 做版本控制？</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#"><span class="toc-nav-text">Service Worker 缓存实时生效</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">Service Worker 实时生效的策略</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#"><span class="toc-nav-text">sw-register-webpack-plugin</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">安装</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#"><span class="toc-nav-text">使用</span></a></li></ol></li></ol>
        
        </div>
      </aside>
    

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#PWA" title="PWA">PWA</a>
                        
                          <a class="tag" href="/tags/#Service Worker" title="Service Worker">Service Worker</a>
                        
                          <a class="tag" href="/tags/#Lavas" title="Lavas">Lavas</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://ielgnaw.com" target="_blank">ielgnaw</a></li>
                    
                        <li><a href="http://efe.baidu.com" target="_blank">EFE</a></li>
                    
                </ul>
                

                <!-- github isuue comment container-->
                
                    <hr>
                    <div id="comments-container"></div>
                
            </div>
        </div>
    </div>
</article>




<!-- github issue comment embedded js start -->
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    var gitment = new Gitment({
        id: 'https://zoumiaojiang.com/article/how-regist-service-worker-for-pwa/', // 可选。默认为 location.href
        owner: 'zoumiaojiang',
        repo: 'zoumiaojiang.github.io',
        oauth: {
            client_id: 'da14bf98138076476f70',
            client_secret: 'a7ce31d619df43bd15798cc9f05996a6aa8f36d2',
        }
    })
    gitment.render('comments-container');
</script>
<!-- github issue embedded js code start end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: ''
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
        // hack for hexo toc helper's bug
        var anchorlinks = document.querySelectorAll('.anchorjs-link');
        var links = document.querySelectorAll('.toc-nav-link');

        for (var i = 0; i < anchorlinks.length; i++) {
            links[i].href = anchorlinks[i].href;
        }
    });
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                    <li>
                        <a target="_blank" href="https://twitter.com/zoumiaojiang">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/zoumiaojiang">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/zoumiaojiang">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank"  href="https://www.linkedin.com/in/淼江-邹-0909b9b3">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; zoumiaojiang 2020 
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/zoumiaojiang-blog.js"></script>



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://zoumiaojiang.com/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = 'ae67586e8cdb510a82a880c6681b8d22';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>







	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js" async=""></script>
    <script type="text/javascript" src="/js/toc.js" async=""></script>
<!-- Image to hack wechat -->
<!-- <img src="https://zoumiaojiang.com/img/icon_wechat.png" width="0" height="0" /> -->
<!-- Migrate from head to bottom, no longer block render and still work -->

<script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>